// 0x → Express.js Backend Server Generator
// Orchestrates backend AST nodes into a complete, runnable Express server

import type {
  ASTNode, GeneratedCode, Expression, Statement,
  EndpointNode, MiddlewareNode, QueueNode, CronNode, CacheNode,
  WebhookNode, StorageNode, MigrateNode, SeedNode,
  ModelNode, AuthDecl, EnvNode,
} from '../ast.js';
import { genExpr, genStatement, ctx, GenContext, bodyContainsAwait } from './react.js';
import { capitalize } from './shared.js';

export function generateBackend(ast: ASTNode[]): GeneratedCode {
  const c = ctx();
  const imports = new Set<string>();
  const middlewareDefs: string[] = [];
  const routeDefs: string[] = [];
  const queueDefs: string[] = [];
  const cronDefs: string[] = [];
  const cacheDefs: string[] = [];
  const modelDefs: string[] = [];
  const migrationDefs: string[] = [];
  const seedDefs: string[] = [];
  const envDefs: string[] = [];
  const miscDefs: string[] = [];

  // Always need express
  imports.add('express');

  for (const node of ast) {
    switch (node.type) {
      case 'Endpoint':
        genEndpoint(node, c, imports, routeDefs);
        break;
      case 'Middleware':
        genMiddleware(node, c, middlewareDefs);
        break;
      case 'Queue':
        imports.add('bull');
        genQueue(node, c, queueDefs);
        break;
      case 'Cron':
        imports.add('node-cron');
        genCron(node, c, cronDefs);
        break;
      case 'Cache':
        genCache(node, c, cacheDefs, imports);
        break;
      case 'Webhook':
        genWebhook(node, c, routeDefs);
        break;
      case 'Storage':
        genStorage(node, c, miscDefs, imports);
        break;
      case 'Migrate':
        genMigration(node, c, migrationDefs);
        break;
      case 'Seed':
        genSeed(node, c, seedDefs);
        break;
      case 'Model':
        genModel(node, c, modelDefs);
        break;
      case 'AuthDecl':
        genAuth(node, c, middlewareDefs, imports);
        break;
      case 'Env':
        genEnv(node, envDefs);
        break;
      default:
        // Skip UI nodes and other non-backend nodes
        break;
    }
  }

  // Assemble the complete server file
  const lines: string[] = [];
  lines.push('// Generated by 0x — Express Server');
  lines.push('');

  // Import section
  lines.push(`import express from 'express';`);
  lines.push(`import cors from 'cors';`);
  if (imports.has('bull')) {
    lines.push(`import Bull from 'bull';`);
  }
  if (imports.has('node-cron')) {
    lines.push(`import cron from 'node-cron';`);
  }
  if (imports.has('jsonwebtoken')) {
    lines.push(`import jwt from 'jsonwebtoken';`);
  }
  if (imports.has('bcrypt')) {
    lines.push(`import bcrypt from 'bcrypt';`);
  }
  if (imports.has('@aws-sdk/client-s3')) {
    lines.push(`import { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand } from '@aws-sdk/client-s3';`);
  }
  if (imports.has('ioredis')) {
    lines.push(`import Redis from 'ioredis';`);
  }
  lines.push('');

  // Environment variables
  if (envDefs.length > 0) {
    lines.push('// Environment');
    lines.push(...envDefs);
    lines.push('');
  }

  // App setup
  lines.push('const app = express();');
  lines.push('const PORT = process.env.PORT || 3000;');
  lines.push('');
  lines.push('// Middleware');
  lines.push('app.use(cors());');
  lines.push('app.use(express.json());');
  lines.push('app.use(express.urlencoded({ extended: true }));');
  lines.push('');

  // Models
  if (modelDefs.length > 0) {
    lines.push('// Models');
    lines.push(...modelDefs);
    lines.push('');
  }

  // Cache
  if (cacheDefs.length > 0) {
    lines.push('// Cache');
    lines.push(...cacheDefs);
    lines.push('');
  }

  // Storage
  if (miscDefs.length > 0) {
    lines.push('// Storage');
    lines.push(...miscDefs);
    lines.push('');
  }

  // Custom middleware definitions
  if (middlewareDefs.length > 0) {
    lines.push('// Custom Middleware');
    lines.push(...middlewareDefs);
    lines.push('');
  }

  // Routes (endpoints + webhooks)
  if (routeDefs.length > 0) {
    lines.push('// Routes');
    lines.push(...routeDefs);
    lines.push('');
  }

  // Queues
  if (queueDefs.length > 0) {
    lines.push('// Background Queues');
    lines.push(...queueDefs);
    lines.push('');
  }

  // Cron jobs
  if (cronDefs.length > 0) {
    lines.push('// Scheduled Tasks');
    lines.push(...cronDefs);
    lines.push('');
  }

  // Migrations
  if (migrationDefs.length > 0) {
    lines.push('// Migrations');
    lines.push(...migrationDefs);
    lines.push('');
  }

  // Seeds
  if (seedDefs.length > 0) {
    lines.push('// Seeds');
    lines.push(...seedDefs);
    lines.push('');
  }

  // Health check
  lines.push(`app.get('/health', (req, res) => {`);
  lines.push(`  res.json({ status: 'ok', uptime: process.uptime() });`);
  lines.push(`});`);
  lines.push('');

  // Server start
  lines.push(`app.listen(PORT, () => {`);
  lines.push(`  console.log(\`Server running on port \${PORT}\`);`);
  lines.push(`});`);
  lines.push('');
  lines.push('export default app;');

  const code = lines.join('\n');
  return {
    code,
    filename: 'server.ts',
    imports: code.match(/^import .+$/gm) || [],
    lineCount: code.split('\n').length,
    tokenCount: code.split(/\s+/).filter(t => t.length > 0).length,
  };
}

function genEndpoint(node: EndpointNode, c: GenContext, imports: Set<string>, routes: string[]): void {
  const method = node.method.toLowerCase();
  const isAsync = bodyContainsAwait(node.handler);
  const mw = node.middleware.length > 0 ? node.middleware.join(', ') + ', ' : '';

  routes.push(`app.${method}('${node.path}', ${mw}${isAsync ? 'async ' : ''}(req, res) => {`);
  routes.push(`  try {`);
  for (const stmt of node.handler) {
    routes.push(`    ${genStatement(stmt, c)}`);
  }
  routes.push(`  } catch (error) {`);
  routes.push(`    console.error('[${method.toUpperCase()} ${node.path}]', error);`);
  routes.push(`    res.status(500).json({ error: error.message });`);
  routes.push(`  }`);
  routes.push(`});`);
  routes.push('');
}

function genMiddleware(node: MiddlewareNode, c: GenContext, defs: string[]): void {
  const isAsync = bodyContainsAwait(node.handler);
  defs.push(`${isAsync ? 'async ' : ''}function ${node.name}(req, res, next) {`);
  for (const stmt of node.handler) {
    defs.push(`  ${genStatement(stmt, c)}`);
  }
  defs.push(`}`);
  defs.push('');
}

function genQueue(node: QueueNode, c: GenContext, defs: string[]): void {
  const isAsync = bodyContainsAwait(node.handler);
  defs.push(`const ${node.name}Queue = new Bull('${node.name}', process.env.REDIS_URL || 'redis://localhost:6379');`);
  defs.push(`${node.name}Queue.process(${isAsync ? 'async ' : ''}(job) => {`);
  for (const stmt of node.handler) {
    defs.push(`  ${genStatement(stmt, c)}`);
  }
  defs.push(`});`);
  defs.push('');
}

function genCron(node: CronNode, c: GenContext, defs: string[]): void {
  const isAsync = bodyContainsAwait(node.handler);
  defs.push(`cron.schedule('${node.schedule}', ${isAsync ? 'async ' : ''}() => {`);
  defs.push(`  console.log('[Cron:${node.name}] Running...');`);
  defs.push(`  try {`);
  for (const stmt of node.handler) {
    defs.push(`    ${genStatement(stmt, c)}`);
  }
  defs.push(`  } catch (error) {`);
  defs.push(`    console.error('[Cron:${node.name}]', error);`);
  defs.push(`  }`);
  defs.push(`});`);
  defs.push('');
}

function genCache(node: CacheNode, c: GenContext, defs: string[], imports: Set<string>): void {
  const ttl = node.ttl ? genExpr(node.ttl, c) : '300';
  if (node.strategy === 'redis') {
    imports.add('ioredis');
    defs.push(`const ${node.name}Redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379');`);
    defs.push(`const ${node.name}Cache = {`);
    defs.push(`  async get(key) { const v = await ${node.name}Redis.get(key); return v ? JSON.parse(v) : null; },`);
    defs.push(`  async set(key, value) { await ${node.name}Redis.set(key, JSON.stringify(value), 'EX', ${ttl}); },`);
    defs.push(`  async del(key) { await ${node.name}Redis.del(key); },`);
    defs.push(`};`);
  } else {
    defs.push(`const ${node.name}Store = new Map();`);
    defs.push(`const ${node.name}Expiry = new Map();`);
    defs.push(`const ${node.name}Cache = {`);
    defs.push(`  get(key) {`);
    defs.push(`    const exp = ${node.name}Expiry.get(key);`);
    defs.push(`    if (exp && Date.now() > exp) { ${node.name}Store.delete(key); ${node.name}Expiry.delete(key); return null; }`);
    defs.push(`    return ${node.name}Store.get(key) ?? null;`);
    defs.push(`  },`);
    defs.push(`  set(key, value) { ${node.name}Store.set(key, value); ${node.name}Expiry.set(key, Date.now() + ${ttl} * 1000); },`);
    defs.push(`  del(key) { ${node.name}Store.delete(key); ${node.name}Expiry.delete(key); },`);
    defs.push(`};`);
  }
  defs.push('');
}

function genWebhook(node: WebhookNode, c: GenContext, routes: string[]): void {
  const isAsync = bodyContainsAwait(node.handler);
  routes.push(`app.post('${node.path}', ${isAsync ? 'async ' : ''}(req, res) => {`);
  routes.push(`  const payload = req.body;`);
  routes.push(`  try {`);
  for (const stmt of node.handler) {
    routes.push(`    ${genStatement(stmt, c)}`);
  }
  routes.push(`    res.status(200).json({ ok: true });`);
  routes.push(`  } catch (error) {`);
  routes.push(`    console.error('[Webhook:${node.name}]', error);`);
  routes.push(`    res.status(500).json({ error: error.message });`);
  routes.push(`  }`);
  routes.push(`});`);
  routes.push('');
}

function genStorage(node: StorageNode, c: GenContext, defs: string[], imports: Set<string>): void {
  const bucket = node.props['bucket'] ? genExpr(node.props['bucket'], c) : `'${node.name}'`;
  if (node.provider === 's3') {
    imports.add('@aws-sdk/client-s3');
    defs.push(`const ${node.name}Client = new S3Client({ region: process.env.AWS_REGION || 'us-east-1' });`);
    defs.push(`const ${node.name}Bucket = ${bucket};`);
    defs.push(`const ${node.name} = {`);
    defs.push(`  async upload(key, body, contentType = 'application/octet-stream') {`);
    defs.push(`    await ${node.name}Client.send(new PutObjectCommand({ Bucket: ${node.name}Bucket, Key: key, Body: body, ContentType: contentType }));`);
    defs.push(`  },`);
    defs.push(`  async download(key) {`);
    defs.push(`    const res = await ${node.name}Client.send(new GetObjectCommand({ Bucket: ${node.name}Bucket, Key: key }));`);
    defs.push(`    return res.Body;`);
    defs.push(`  },`);
    defs.push(`  async remove(key) {`);
    defs.push(`    await ${node.name}Client.send(new DeleteObjectCommand({ Bucket: ${node.name}Bucket, Key: key }));`);
    defs.push(`  },`);
    defs.push(`};`);
  } else {
    defs.push(`const ${node.name} = {`);
    defs.push(`  provider: '${node.provider}',`);
    defs.push(`  bucket: ${bucket},`);
    defs.push(`  async upload(key, data) { console.log('[Storage:${node.name}] upload:', key); },`);
    defs.push(`  async download(key) { console.log('[Storage:${node.name}] download:', key); },`);
    defs.push(`  async remove(key) { console.log('[Storage:${node.name}] remove:', key); },`);
    defs.push(`};`);
  }
  defs.push('');
}

function genMigration(node: MigrateNode, c: GenContext, defs: string[]): void {
  defs.push(`const migration_${node.name} = {`);
  defs.push(`  name: '${node.name}',`);
  defs.push(`  async up(db) {`);
  for (const stmt of node.up) {
    defs.push(`    ${genStatement(stmt, c)}`);
  }
  defs.push(`  },`);
  defs.push(`  async down(db) {`);
  for (const stmt of node.down) {
    defs.push(`    ${genStatement(stmt, c)}`);
  }
  defs.push(`  },`);
  defs.push(`};`);
  defs.push('');
}

function genSeed(node: SeedNode, c: GenContext, defs: string[]): void {
  const data = genExpr(node.data, c);
  defs.push(`async function seed${capitalize(node.model)}(db) {`);
  if (node.count) {
    const count = genExpr(node.count, c);
    defs.push(`  const seedData = Array.from({ length: ${count} }, (_, i) => ({ ...${data}, id: i + 1 }));`);
    defs.push(`  for (const item of seedData) { await db.${node.model.toLowerCase()}.create(item); }`);
  } else {
    defs.push(`  const items = Array.isArray(${data}) ? ${data} : [${data}];`);
    defs.push(`  for (const item of items) { await db.${node.model.toLowerCase()}.create(item); }`);
  }
  defs.push(`}`);
  defs.push('');
}

function genModel(node: ModelNode, c: GenContext, defs: string[]): void {
  const fields = node.fields.map(f => {
    const req = f.defaultValue === null ? ', required: true' : '';
    return `    ${f.name}: { type: '${f.fieldType.kind === 'primitive' ? f.fieldType.name : 'any'}'${req} }`;
  }).join(',\n');

  const name = node.name;
  const lower = name.toLowerCase();

  defs.push(`// Model: ${name}`);
  defs.push(`const ${name}Schema = {`);
  defs.push(`  fields: {`);
  defs.push(fields);
  defs.push(`  },`);
  defs.push(`};`);
  defs.push('');

  // Auto CRUD routes
  defs.push(`// Auto-generated CRUD for ${name}`);
  defs.push(`app.get('/api/${lower}', async (req, res) => { res.json([]); });`);
  defs.push(`app.get('/api/${lower}/:id', async (req, res) => { res.json({ id: req.params.id }); });`);
  defs.push(`app.post('/api/${lower}', async (req, res) => { res.status(201).json(req.body); });`);
  defs.push(`app.put('/api/${lower}/:id', async (req, res) => { res.json({ ...req.body, id: req.params.id }); });`);
  defs.push(`app.delete('/api/${lower}/:id', async (req, res) => { res.status(204).end(); });`);
  defs.push('');
}

function genAuth(node: AuthDecl, c: GenContext, defs: string[], imports: Set<string>): void {
  imports.add('jsonwebtoken');
  imports.add('bcrypt');

  const provider = node.provider;
  defs.push(`// Auth: ${provider}`);
  defs.push(`const JWT_SECRET = process.env.JWT_SECRET || 'change-me';`);
  defs.push('');
  defs.push(`function authMiddleware(req, res, next) {`);
  defs.push(`  const token = req.headers.authorization?.replace('Bearer ', '');`);
  defs.push(`  if (!token) return res.status(401).json({ error: 'No token provided' });`);
  defs.push(`  try {`);
  defs.push(`    req.user = jwt.verify(token, JWT_SECRET);`);
  defs.push(`    next();`);
  defs.push(`  } catch {`);
  defs.push(`    res.status(401).json({ error: 'Invalid token' });`);
  defs.push(`  }`);
  defs.push(`}`);
  defs.push('');
}

function genEnv(node: EnvNode, defs: string[]): void {
  defs.push(`// Environment: ${node.envType}`);
  for (const v of node.vars) {
    const c = ctx();
    const val = genExpr(v.value, c);
    if (v.secret) {
      defs.push(`const ${v.name} = process.env.${v.name} || ${val}; // secret`);
    } else {
      defs.push(`const ${v.name} = process.env.${v.name} || ${val};`);
    }
  }
}
